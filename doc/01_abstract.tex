
\section*{Abstract} \label{sec:abstract}

The main defined goal of the Project is to have a ``Motor'' in \GLS{eeros} which is simulated in \Gls{gazebo}.

Just when starting to setup the whole toolchain \GLS{eeros}, \GLS{ros} and \GLS{gazebo} it showed that \GLS{eeros} is not working together with the new \GLS{ros}-2.
Current Linux distributions do not support \GLS{ros}-1 anymore out of the box because it will be End of Life soon.
This was the point, where the first goal changed to port \GLS{eeros} to \GLS{ros}-2.
The second goal then was to have a motor simulation as defined by the initial definition of the task.

This process took quite long, due to the fact that I did neither know \GLS{eeros} nor \GLS{ros}.
Also the documentation of both projects, in my point of view, lack of description on how they should be used.
For \GLS{ros}-1 there exists quite a lot of tutorials, Q\&A's and Code examples; \GLS{ros}-2 seems not yet to be at that point.

One of the biggest challenges was therefore to understand the way \GLS{ros}-1 was working and how this changed in \GLS{ros}-2.
The main change is, that in \GLS{ros}-2 the whole application spins, and not only a node.
The effect of that behavior: As soon as a subscriber is created, the whole \GLS{eeros} program is locked.
However, there was a Executor introduced in \GLS{ros}-2, which does similar things than the \GLS{eeros}-Executor.

As a quick fix to solve the problem and not refactor \GLS{eeros} completely, a \GLS{ros}-2 Executor is used for all Subscriptions.
All received Messages are stored in a queue and processed as soon as the \GLS{eeros}-Executor calls for them.
If a \GLS{ros}-Topic is the main clock, the process is inverse: The \GLS{ros}-2 Executor triggers the \GLS{eeros}-Executor for processing al the blocks.

For having a motor simulated in Gazebo, a topic has to be read in gazebo which values will then be used for the simulation.
For this to work as expected, there must be a plugin in \Gls{gazebo} which would take ``power'' or something like that  and then simulate rotation which could then be used for example for a movement.
Although there is a third-party plugin available, that one is not yet ported to \GLS{ros}-2.
Therefore a different plugin was used which takes a value for a joint and simulates the movement.
This movement is then written by an other plugin back to an other topic which is used in \GLS{eeros} again for calculation.
This is not a real ``Motor-Simulation'' as it was thought to be, but shows the concept of how \GLS{eeros} can work together with \Gls{gazebo}.
